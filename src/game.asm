* Game with motion-captured animation for the TI-99/4A home computer.
*
* Copyright (c) 2024 Eric Lafortune
*
* This program is free software; you can redistribute it and/or modify it
* under the terms of the GNU General Public License as published by the Free
* Software Foundation; either version 2 of the License, or (at your option)
* any later version.
*
* This program is distributed in the hope that it will be useful, but WITHOUT
* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
* more details.
*
* You should have received a copy of the GNU General Public License along
* with this program; if not, write to the Free Software Foundation, Inc.,
* 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA

    copy "include/cpu.asm"
    copy "include/vdp.asm"
    copy "include/colors.asm"
    copy "include/sound.asm"
    copy "include/speech.asm"
    copy "include/cru.asm"
    copy "include/mouse.asm"
    copy "include/swap_macros.asm"

    copy "initialize_graphics.asm"
    copy "draw_landscape.asm"
    copy "draw_player.asm"
    copy "draw_objects.asm"
    copy "update_player.asm"
    copy "check_input.asm"
    copy "update_objects.asm"
    copy "ordinates.asm"
    copy "video_macros.asm"
    copy "blit_macros.asm"
    copy "sound_macros.asm"
    copy "speech_macros.asm"
    copy "../out/sprite_names.asm" ; Generated by the build process.

* Start in module ROM.
    aorg module_memory

* Module header.
module_start
    byte >aa                   ; Header.
    byte 1                     ; Version.
    byte 1                     ; Number of programs.
    byte 0                     ; Unused.
    data 0                     ; Power-up list.
    data program_list          ; Program list (shown in reverse order).
    data 0                     ; DSR list.
    data 0                     ; Subprogram list.

* First element of the program list.
program_list
    data 0                     ; Next element.
    data program_start         ; Program start.
    stri 'STEALTH RUNNER'      ; Program name.
    even

* A single workspace at the end of scratch-pad RAM.
workspace equ scratchpad_end - workspace_size

* The entry point of the program.
program_start
    limi 0
    lwpi workspace

* Cache some I/O addresses in registers.
;   .spchrd_in_register r9     ; Cache the speech read address.
;   .spchwt_in_register r10    ; Cache the speech write address.
;   .sound_in_register  r13    ; Cache the sound address.
    .vdpwa_in_register  r14    ; Cache the VDP address write address.
    .vdpwd_in_register  r15    ; Cache the VDP data write address.

* Copy the main game code to expansion RAM.
    .copy_memory module_memory, expansion_code_end, low_expansion_memory

* Copy the video player code to scratchpad RAM, for better performance.
play_intro_video
    .copy_memory video_code_start, video_code_end, scratchpad

* Play the intro video.
    .initialize_video_graphics

    li   r0, intro_video_bank
    bl   @play_video

* Wait for a key press (in key column 0).
    li   r12, cru_write_keyboard_column
    clr  r0
    ldcr r0, cru_keyboard_column_bit_count
    li   r12, cru_read_keyboard_rows

key_press_loop
    stcr r0, cru_read_keyboard_row_bit_count
    ci   r0, >ff00
    jeq  key_press_loop

* Continue running the code from expansion RAM, so we can switch between
* module memory banks more easily.
    b    @expansion_code

expansion_code_start
    xorg $ - module_memory + low_expansion_memory
expansion_code

* Copy the VDP blitting code to scratchpad RAM, for better performance.
    .copy_memory blit_code_start, blit_code_end, scratchpad

play_game
    .switch_bank @code_bank    ; The graphics are in the code bank.
    .initialize_game_graphics

* Initialize the player and the objects from the world data.
    .switch_bank @landscape_objects_bank
    li   r0, module_memory

    .initialize_player
    .initialize_objects

* Reset the sound pointers.
    seto @current_tone0
    seto @current_tone1
    seto @current_tone2
    seto @current_noise

* Reset the speech pointer.
    clr  @current_speech
    clr  @current_speech_length

* Initialize the supersprite/quadsprite cache.
    bl   @initialize_quadsprites

    .start_speech speech_letsgo

* Keep track of even/odd frames.
    clr  @frame_timestamp

* The main game loop.
game_loop
    mov  @frame_timestamp, r0  ; Even or odd frame (at 60 Hz)?
    srl  r0, 1
    jnc  !                     ; Even frame: draw the background
    b    @draw_player          ; Odd frame:  draw the player.
!
* Draw and update the objects and the landscape (at 30 Hz).
    .draw_objects
    .draw_landscape_delta
    .update_objects

    b    @play_speech

* Draw and update the player (at 30 Hz).
draw_player
    .draw_player
    .update_player
    .check_input

* Check if any of the quit keys is pressed (at 30 Hz).
check_quit
    .test_keyboard 4, 3        ; Pressing '6' = <Proceed>?
    jeq  !!!!
!   .test_keyboard_row 3       ; Wait until '6' is released.
    jne  -!
!   .test_keyboard_row 3       ; Pause until '6' is pressed again.
    jeq  -!
!   .test_keyboard_row 3       ; Wait until '6' is released again.
    jne  -!
!
    .test_keyboard 2, 3        ; Pressing '8' = <Redo>?
    jeq  !
    b    @play_game            ; Then restart the game.
!
    .test_keyboard 1, 3        ; Pressing '9' = <Back>?
    jeq  !
    b    @play_intro_video     ; Then restart from the intro video.
!
    .test_keyboard 0, 0        ; Pressing '=' = <Quit>?
    jeq  !
    blwp @0                    ; Then quit.
!

* Play any speech data (at 60 Hz).
play_speech
    .play_speech

* After all drawing, updating, and checking, wait for the Vsync.
wait_for_vsync
    .wait_for_vsync

* Continue with the next frame in the main game loop.
    inc  @frame_timestamp
    b    @game_loop

* Various subroutines.
    copy "kill_player.asm"
    copy "supersprites.asm"
    copy "directions.asm"

    aorg
expansion_code_end


* Video player subroutine, run from scratchpad RAM, for speed and to be able to
* switch between memory banks.
video_code_start
    xorg scratchpad

    copy "video.asm"

    .print 'Unused bytes in scratchpad after video player code:', workspace - $

    .ifgt  $, workspace
    .error 'Video player code too large for scratchpad'
    .endif

    aorg
video_code_end

* Blitting subroutines, run from scratchpad RAM, for speed and to be able to
* switch between memory banks.
blit_code_start
    xorg scratchpad

    copy "blit.asm"

    ; Also, a tiny speech subroutine that has to be run from scratchpad RAM.
    .speech_read_status_byte_subroutine

    .print 'Unused bytes in scratchpad after blitting code:', workspace - $

    .ifgt  $, workspace
    .error 'Blitting code too large for scratchpad'
    .endif

    aorg
blit_code_end

    copy "direction_data.asm"
    copy "motion_data.asm"
    copy "graphics_data.asm"
    copy "sound_data.asm"

    .ifgt  $, >8000
    .error 'Program code too large for first memory bank.'
    .endif

    .print 'Unused bytes in main code bank:', >8000 - $

* Banks with preprocessed data for the intro video, graphics, levels,...
    .next_bank
;intro_video
    bcopy "../out/intro.tms"
    .next_bank
;player_animations
    bcopy "../out/player.dat"
;landscape_objects
    bcopy "../out/levels/00_objects.dat"
    .next_bank
;out/levels/00_characters_00
    bcopy "../out/levels/00_00.dat"
    .next_bank
;out/levels/00_characters_10
    bcopy "../out/levels/00_10.dat"
    .next_bank
;out/levels/00_characters_01
    bcopy "../out/levels/00_01.dat"
    .next_bank
;out/levels/00_characters_11
    bcopy "../out/levels/00_11.dat"
    .next_bank
;out/levels/00_mask
    bcopy "../out/levels/00_mask.dat"
    .next_bank
;sprite_index
    bcopy "../out/sprite_index.dat"
    .next_bank
;sprite_positions
    bcopy "../out/sprite_positions.dat"
    .next_bank
;sprite_patterns
    bcopy "../out/sprite_patterns.dat"
    .next_bank
;speech_data
    xorg module_memory
    copy "speech_data.asm"
    aorg
    .next_bank
module_end

* Global variables.
    dorg >a000

* Object lists.
batteries                 bss >0100 ; X ordinate, y ordinate.
mines                     bss >0100 ; X ordinate, y ordinate, explosion.
drones                    bss >0100 ; X ordinate, y ordinate, fractional x ordinate, fractional y ordinate, direction (0..15 = 4 bits).
turrets                   bss >0100 ; X ordinate, y ordinate, direction (0..15 = 4 bits).

* Supersprite/quadsprite cache pointers.
vdp_quadsprite_numbers    bss 1024 * 2 ; The VDP quadsprite number (0..63 = 6 bits, shifted left 1 bit) for each CPU ROM quadsprite number (0..1023).
cpu_quadsprite_numbers    bss 64 * 2   ; The CPU ROM quadsprite number (0..1023, shifted left 1 bit) for each VDP quadsprite number (0..63).
vdp_quadsprite_timestamps bss 64 * 2   ; The timestamp of the most recent frame for each VDP quadsprite number (0..63).
sprite_cache_queue        bss 32 * 2   ; The queue with CPU quadsprite numbers (shifted left 1 bit) to be written to VDP memory.

vdp_quadsprite_counter data 0

* Video frame variable.
frame_timestamp data 0 ; Counter for the current frame
                       ; (used for caching and even/odd tests).

* Sound variables.
current_tone0 data 0 ; The start address of the currently playing tone 0.
current_tone1 data 0 ; The start address of the currently playing tone 1.
current_tone2 data 0 ; The start address of the currently playing tone 2.
current_noise data 0 ; The start address of the currently playing noise.

* Speech variables.
current_speech        data 0; The address of the speech data currently being spoken.
current_speech_length data 0; The address of the speech data currently being spoken.

* Player variables.
player_x           data 0 ; X ordinate, expressed in pixels.
player_y           data 0 ; Y ordinate, expressed in pixels.
player_fx          data 0 ; Fractional x ordinate (fixed point 8.8 bits).
player_fy          data 0 ; Fractional y ordinate (fixed point 8.8 bits).
player_speed       data 0 ; Speed (-1 for dying, 0 for standing,...)
player_direction   data 0 ; Direction (0..15).

mouse_x data 0 ; Mouse x ordinate around player.
mouse_y data 0 ; Mouse y ordinate around player.

player_animation_bank          data 0 ; Animation memory bank (>6000, >6002,...).
previous_player_animation_bank data 0
player_frame                   data 0 ; Animation frame (0..n-1).
previous_player_frame          data 0

* Derived landscape display variables.
previous_landscape_patterns_offset    data 0 ; Most recently drawn landscape patterns source offset.
previous_landscape_character_quadrant data 0 ; Most recently drawn landscape character quadrant.

* Target variables.
target_x data 0 ; X ordinate, expressed in pixels.
target_y data 0 ; Y ordinate, expressed in pixels.

* Battery charge variables.
charge_count data 0 ; Number of EMPs available.
charge_frame data 0 ; Frame of the charge meter.

* Emp variables.
emp_x         data 0 ; X ordinate, expressed in pixels.
emp_y         data 0 ; Y ordinate, expressed in pixels.
emp_fx        data 0 ; Fractional x ordinate (fixed point 8.8 bits).
emp_fy        data 0 ; Fractional y ordinate (fixed point 8.8 bits).
emp_direction data 0 ; Direction (0..15).

* Bullet variables.
bullet_x         data 0 ; X ordinate, expressed in pixels.
bullet_y         data 0 ; Y ordinate, expressed in pixels.
bullet_fx        data 0 ; Fractional x ordinate (fixed point 8.8 bits).
bullet_fy        data 0 ; Fractional y ordinate (fixed point 8.8 bits).
bullet_direction data 0 ; Direction (0..15).

* The memory bank addresses: >6000, >6002,.... (multiples of 2).
    dorg >6000

code_bank                        bss 2 * 1
intro_video_bank                 bss 2 * 3
dying_player_animation_banks     bss 2 * 16
standing_player_animation_banks  bss 2 * 9 * 16
landscape_objects_bank           bss 2 * 1
landscape_characters_banks       bss 2 * 4
landscape_mask_bank              bss 2 * 1
sprite_index_bank                bss 2 * 1
sprite_positions_banks           bss 2 * 4
sprite_patterns_banks            bss 2 * 2
speech_data_bank                 bss 2 * 1

    .ifne  module_start + (($ & >00fe) * >1000), module_end + >1fff & >e000
    .error 'Incorrect memory bank addresses.'
    .endif
